import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_colorpicker/flutter_colorpicker.dart';

import '../../../controller/controllers/editor-controller.dart';
import '../../../document/models/attributes/attribute.model.dart';
import '../../../editor/services/run-build.service.dart';
import '../../../shared/models/editor-icon-theme.model.dart';
import '../../../shared/state/editor-state-receiver.dart';
import '../../../shared/state/editor.state.dart';
import '../../../shared/translations/toolbar.i18n.dart';
import '../../../shared/utils/color.utils.dart';
import '../../../styles/services/styles.service.dart';
import '../../services/toolbar.service.dart';
import '../toolbar.dart';

// Controls color styles (text color and text background).
// When pressed, a color palette modal is displayed.
// ignore: must_be_immutable
class ColorButton extends StatefulWidget implements EditorStateReceiver {
  final IconData icon;
  final double iconSize;
  final bool background;
  final EditorController controller;
  final EditorIconThemeM? iconTheme;
  final double buttonsSpacing;
  late EditorState _state;

  ColorButton({
    required this.icon,
    required this.controller,
    required this.background,
    required this.buttonsSpacing,
    this.iconSize = defaultIconSize,
    this.iconTheme,
    Key? key,
  }) : super(key: key) {
    controller.setStateInEditorStateReceiver(this);
  }

  @override
  _ColorButtonState createState() => _ColorButtonState();

  @override
  void cacheStateStore(EditorState state) {
    _state = state;
  }
}

class _ColorButtonState extends State<ColorButton> {
  late final RunBuildService _runBuildService;
  late final StylesService _stylesService;
  late final ToolbarService _toolbarService;

  var _isToggledColor = false;
  var _isToggledBackground = false;
  var _isWhite = false;
  var _isWhiteBackground = false;
  var _iconColorBgr = Colors.white;
  var _iconColor = Colors.white;
  var _fillColorBgr = Colors.white;
  var _fillColor = Colors.white;
  StreamSubscription? _runBuild$L;

  @override
  void initState() {
    _runBuildService = RunBuildService(widget._state);
    _stylesService = StylesService(widget._state);
    _toolbarService = ToolbarService(widget._state);

    super.initState();
    _cacheToggledColors();
    _subscribeToRunBuild();
  }

  @override
  void dispose() {
    _runBuild$L?.cancel();
    super.dispose();
  }

  @override
  void didUpdateWidget(covariant ColorButton oldWidget) {
    super.didUpdateWidget(oldWidget);

    // If a new controller was generated by setState() in the parent
    // we need to subscribe to the new state store.
    if (oldWidget.controller != widget.controller) {
      _runBuild$L?.cancel();
      widget.controller.setStateInEditorStateReceiver(widget);
      _subscribeToRunBuild();
      _cacheToggledColors();
    }
  }

  @override
  Widget build(BuildContext context) {
    _cacheButtonsColors();
    final theme = Theme.of(context);

    return IconBtn(
      highlightElevation: 0,
      hoverElevation: 0,
      buttonsSpacing: widget.buttonsSpacing,
      size: widget.iconSize * iconButtonFactor,
      icon: Icon(
        widget.icon,
        size: widget.iconSize,
        color: isEnabled
            ? widget.background
                ? _iconColorBgr
                : _iconColor
            : theme.disabledColor,
      ),
      fillColor: widget.background ? _fillColorBgr : _fillColor,
      borderRadius: widget.iconTheme?.borderRadius ?? 2,
      onPressed: isEnabled ? _showColorPicker : null,
    );
  }

  // === UTILS ===

  bool get isEnabled => _toolbarService.isStylingEnabled;

  void _subscribeToRunBuild() {
    _runBuild$L =
        _runBuildService.runBuild$.listen((_) => setState(_cacheToggledColors));
  }

  Map<String, AttributeM>? get _attributes =>
      _stylesService.getSelectionStyle().attributes;

  void _cacheToggledColors() {
    if (!(_documentControllerInitialised && _attributes != null)) {
      return;
    }

    _isToggledColor = _stylesService.getIsToggledColor(_attributes!);
    _isToggledBackground = _stylesService.getIsToggledBackground(_attributes!);
    _isWhite = _isToggledColor && _attributes?['color']!.value == '#ffffff';
    _isWhiteBackground =
        _isToggledBackground && _attributes?['background']!.value == '#ffffff';
  }

  void _cacheButtonsColors() {
    final theme = Theme.of(context);

    _iconColor = _isToggledColor && !widget.background && !_isWhite
        ? stringToColor(_attributes?['color']!.value)
        : (widget.iconTheme?.iconUnselectedColor ?? theme.iconTheme.color)!;
    _iconColorBgr =
        _isToggledBackground && widget.background && !_isWhiteBackground
            ? stringToColor(_attributes?['background']!.value)
            : (widget.iconTheme?.iconUnselectedColor ?? theme.iconTheme.color)!;
    _fillColor = _isToggledColor && !widget.background && _isWhite
        ? stringToColor('#ffffff')
        : (widget.iconTheme?.iconUnselectedFillColor ?? theme.canvasColor);
    _fillColorBgr =
        _isToggledBackground && widget.background && _isWhiteBackground
            ? stringToColor('#ffffff')
            : (widget.iconTheme?.iconUnselectedFillColor ?? theme.canvasColor);
  }

  void _showColorPicker() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Select Color'.i18n),
        backgroundColor: Theme.of(context).canvasColor,
        content: SingleChildScrollView(
          child: MaterialPicker(
            pickerColor: const Color(0x00000000),
            onColorChanged: (color) {
              _stylesService.changeSelectionColor(color, widget.background);
              Navigator.of(context).pop();
            },
          ),
        ),
      ),
    );
  }

  bool get _documentControllerInitialised {
    return widget._state.refs.documentControllerInitialised == true;
  }
}
